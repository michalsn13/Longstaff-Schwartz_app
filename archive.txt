class GBM2d:
    def __init__(self, p, S0s, mus, sigmas, r, values_per_year = 50):
        self.p = p
        self.S0 = S0s
        self.mu = mus
        self.sigma = sigmas
        self.r = r
        self.values_per_year = values_per_year
    def simulate_P(self, size, T):
        dt = 1/self.values_per_year
        price_moments = np.arange(1,T/dt + 1)
        Sigma=dt*np.minimum(np.tile(price_moments,(len(price_moments),1)),np.tile(price_moments.reshape(-1,1),(1,len(price_moments))))
        B1 = np.random.multivariate_normal(size=size, mean= np.zeros(len(price_moments)), cov = Sigma)
        B2 = self.p*B1 + np.sqrt(1-self.p**2)*np.random.multivariate_normal(size=size, mean= np.zeros(len(price_moments)), cov = Sigma)
        sims1 = self.S0[0] * np.exp((self.mu[0] - 0.5 * self.sigma[0]**2) * price_moments * dt + self.sigma[0] * B1)
        sims2 = self.S0[1] * np.exp((self.mu[1] - 0.5 * self.sigma[1]**2) * price_moments * dt + self.sigma[1] * B2)
        return np.array([sims1,sims2])
    def simulate_Q(self, size, T, quantiles = False):
        dt = 1/self.values_per_year
        price_moments = np.arange(1,T/dt + 1)
        Sigma=dt*np.minimum(np.tile(price_moments,(len(price_moments),1)),np.tile(price_moments.reshape(-1,1),(1,len(price_moments))))
        B1 = np.random.multivariate_normal(size=size, mean= np.zeros(len(price_moments)), cov = Sigma)
        B2 = self.p*B1 + np.sqrt(1-self.p**2)*np.random.multivariate_normal(size=size, mean= np.zeros(len(price_moments)), cov = Sigma)
        sims1 = self.S0[0] * np.exp((self.r - 0.5 * self.sigma[0]**2) * price_moments * dt + self.sigma[0] * B1)
        sims2 = self.S0[1] * np.exp((self.r - 0.5 * self.sigma[1]**2) * price_moments * dt + self.sigma[1] * B2)
        return np.array([sims1,sims2])
    def transition_dens(self, x_curr, x_next):
        S = np.array([[self.sigma[0]**2, self.sigma[0]*self.sigma[1]*self.p],[self.sigma[0]*self.sigma[1]*self.p, self.sigma[1]**2]])
        denominator = 2*np.pi*np.sqrt(np.linalg.det(S))*x_next.prod(axis=0)
        mean =  np.array([self.r, self.r]) - 0.5*np.diag(S)  + np.log(x_curr)
        numerator =np.diag(np.exp(-(np.log(x_next).T-mean)@np.linalg.inv(S)@(np.log(x_next).T-mean).T))
        return (numerator/denominator).flatten()
